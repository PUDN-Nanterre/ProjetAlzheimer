---
title: "Alzheimer_PUDN"
author: "Remaissa BENDIB, Hanjoon KO, Gracia YAN"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

# Introduction

# Présentation HAL

# Extraction à partir de l'API

Reprendre la méthodo de Abir Gabriel en la modifiant ?

<https://gitlab.huma-num.fr/bchauvel/biblioalzheimer/-/blob/main/1_Extraction/FicheMethode_requeteHAL.Rmd?ref_type=heads>

```{r, include=FALSE}
library(readr)
library(labelled)
library(questionr)
library(stringr)
library(tidyverse)
```

```{r}

# Import des données dans R à partir de l'API HAL
url <- "https://api.archives-ouvertes.fr/search/hal/?q=alzheimer&rows=7000&wt=csv&indent=true&fl=docid,publicationDateY_i,docType_s,language_s,domain_s,primaryDomain_s,openAccess_bool,submitType_s,journalTitle_s,journalPublisher_s,authFullName_s,title_s,subTitle_s,citationRef_s,doiId_s,issue_s,journalIssn_s,volume_s,source_s,licence_s,files_s,journalTitleAbbr_s,title_st,submitType_s,type_s,page_s,publicationDate_s,keyword_s,en_keyword_s,fr_keyword_s,abstract_s,en_abstract_s,fr_abstract_s&sort=publicationDateY_i%20desc"

options(timeout=600) # pour forcer le temps limite de chargement (si faible connexion internet)
download.file(url, destfile = "AlzheimerHAL.csv")

url <- "https://api.archives-ouvertes.fr/search/hal/?q=alzheimer&rows=7000&wt=bibtex&indent=true&fl=docid,publicationDateY_i,docType_s,language_s,domain_s,primaryDomain_s,openAccess_bool,submitType_s,journalTitle_s,journalPublisher_s,authFullName_s,title_s,subTitle_s,citationRef_s,doiId_s,issue_s,journalIssn_s,volume_s,source_s,licence_s,files_s,journalTitleAbbr_s,title_st,submitType_s,type_s,page_s,publicationDate_s,keyword_s,en_keyword_s,fr_keyword_s,abstract_s,en_abstract_s,fr_abstract_s&sort=publicationDateY_i%20desc"

options(timeout=600) # pour forcer le temps limite de chargement (si faible connexion internet)
download.file(url, destfile = "AlzheimerHAL.bib")

# Le fichier csv est ensuite importé dans la session R sous forme de tableau de données (le fichier bibtext sera utilisé ultérieurement).
dataset_alzheimer <- read.csv("AlzheimerHAL.csv")
```

# Nettoyage des données

## Étiquetage des variables

Les variables portent les mêmes noms que les champs sélectionnés dans le lien d'export dans l'API : noms des variables du dataframe

```{r, include=FALSE}
names(dataset_alzheimer)
```

On ajoute des étiquettes aux noms de variables (avec le package labelled), pour les documenter et limiter les risques de mauvaises interprétations.

```{r, include=FALSE}
var_label(dataset_alzheimer) <- list(
  docid = "Identifiant HAL du dépôt", 
  publicationDateY_i = "Date de publication : année", 
  docType_s = "Type de document", 
  language_s = "Langue du document (code ISO 639-1 (alpha-2))", 
  domain_s = "Codes domaines du document", 
  primaryDomain_s = "Domaine primaire", 
  openAccess_bool = "publication en open access", 
  submitType_s = "Type de dépôt", 
  journalTitle_s = "Revue : Titre", 
  journalPublisher_s = "Revue : Editeur", 
  authFullName_s = "Auteur : Nom complet", 
  title_s = "Titres", 
  subTitle_s = "Sous-titre", 
  citationRef_s = "Citation abrégée", 
  doiId_s = "Identifiant DOI", 
  issue_s = "Numéro de revue", 
  journalIssn_s = "Revue : ISSN", 
  volume_s= "Volume", 
  source_s= "Source", 
  licence_s= "Droit d'auteur associé au document", 
  files_s= "URL des fichiers", 
  journalTitleAbbr_s= "Revue : Titre abrégé", 
  title_st= "Titres (sans les mots vides)", 
  type_s= "Type", page_s= "Pagination", 
  publicationDate_s= "Date de publication", 
  keyword_s = "Mots-clés", 
  en_keyword_s = "Mots-clés en anglais", 
  fr_keyword_s = "Mots-clés en français", 
  abstract_s = "Résumé", 
  en_abstract_s = "Résumé en anglais", 
  fr_abstract_s = "Résumé en français")
```

## Étiquetage des modalités

De même pour rendre les modalités plus explicites, par exemple, le type et la langue du document :

```{r, include=FALSE}
val_labels(dataset_alzheimer$docType_s) <- c(
  "Article dans une revue" = "ART", 
  "Article de blog scientifique" = "BLOG", 
  "Communication dans un congrès" = "COMM", 
  "Chapitre d'ouvrage" = "COUV", 
  "N°spécial de revue/special issue" = "ISSUE", 
  "Cours" = "LECTURE", 
  "Autre publication scientifique" = "OTHER", 
  "Ouvrages" = "OUV", 
  "Brevet" = "PATENT", 
  "Poster de conférence" = "POSTER", 
  "Rapport" = "REPORT", 
  "Thèse" = "THESE", 
  "Vidéo" = "VIDEO")
```

```{r, include=FALSE}

freq(dataset_alzheimer$docType_s, sort = "dec", valid = FALSE, total = TRUE) %>% knitr::kable(caption = "Types de documents présents dans le corpus")

```

## Langue

```{r, include=FALSE}
val_labels(dataset_alzheimer$language_s) <- c(
  "Allemand" = "de", 
  "Anglais" = "en", 
  "Espagnol" = "es", 
  "Français" = "fr", 
  "Portugais" = "pt", 
  "Ukrainien" = "uk")
```

```{r, include=FALSE}
freq(dataset_alzheimer$language_s, sort = "dec", valid = FALSE, total = TRUE) %>% 
  knitr::kable(caption = "Langue du document")
```

Les codes domaines sont particulièrement détaillés:

```{r, include=FALSE}
freq(dataset_alzheimer$primaryDomain_s, sort = "dec", valid = FALSE, total = TRUE) %>% 
  head(20) %>% 
  knitr::kable(caption = "Domaines primaires détaillés (les 20 plus fréquents)")
```

On créé une variable `domaine_gpe`pour les regrouper.

extraire les débuts de chaînes de caractères dans une nouvelle variable

termes recherchés : commence par (\^) chim ou (\|) commence par,....

```{r, include=FALSE}
mots <- "^chim|^info|^math|^phys|^scco|^sde|^sdu|^sdv|^shs|^spi|^stat"
```

domaine_gpe prend les modalités extraites de primaryDomains

```{r, include=FALSE}
dataset_alzheimer$domaine_gpe <- str_extract(dataset_alzheimer$primaryDomain_s, pattern = mots)
```

ajoute des étiquettes aux modalités de domaine_gpe

```{r, include=FALSE}
val_labels(dataset_alzheimer$domaine_gpe) <- c( 
  "Chimie" = "chim", 
  "Informatique [cs]" = "info", 
  "Mathématiques [math]" = "math", 
  "Physique [physics]" = "phys", 
  "Économie et finance quantitative [q-fin]" = "qfin", 
  "Sciences cognitives" = "scco", 
  "Sciences de l'environnement" = "sde", 
  "Planète et Univers [physics]" = "sdu", 
  "Sciences du Vivant [q-bio]" = "sdv", 
  "Sciences de l'Homme et Société" = "shs", 
  "Sciences de l'ingénieur [physics]" = "spi", 
  "Statistiques [stat]" = "stat")
```

## Tableau de fréquence

```{r, include=FALSE}
freq(dataset_alzheimer$domaine_gpe, sort = "dec", valid = FALSE) %>% 
  knitr::kable(caption = "Domaines primaires regroupés")

```

TODO On crée aussi une variable domaine_shs, pour identifier les articles dont au moins un des domaines est shs.

```{r, include=FALSE}
dataset_alzheimer$language_gpe <- as.character(dataset_alzheimer$language_s)

dataset_alzheimer$language_gpe[dataset_alzheimer$language_s != "en" & dataset_alzheimer$language_s != "fr"] <- "autre"

val_labels(dataset_alzheimer$language_gpe) <- c( "Anglais" = "en", "Français" = "fr", "Autres" = "autre" )

freq(dataset_alzheimer$language_gpe) %>% 
  knitr::kable(caption = "Langues du corpus")
```

Sauvegarde des données et de leurs étiquettes

On sauvegarde les données et leur configuration dans le fichier "AlzheimerHAL.Rda" qui sera utilisé pour faire les analyses.

```{r, include=FALSE}
save(dataset_alzheimer, file = "AlzheimerHAL.Rda")
```

## Préparation des dataset avant de faire des analyses

-   [Étape 1 :]{.underline} Préparation du dataset général

Dans cette étape, nous procéderons à la préparation du dataset général pour faire des visualisations sur les tendances générales.

-   [Étape 2 :]{.underline} Création d'un sub-dataset spécialisé pour les revues

Dans cette étape, nous créerons un sub-dataset spécifique qui se concentre exclusivement sur les publications de type "revues". Cela permettra une analyse plus approfondie et ciblée sur ce sous-ensemble de données, facilitant ainsi l'extraction d'informations spécifiques liées aux revues.

-   [Etape 3]{.underline} : Enrichissement manuelle des données liées aux types de revues (cette étape viendra dans les analyses, car nous allons seulement enrichir le top20 des revues)

### Étape 1

Préparation du dataset général :

A partir du dataset initial, nous allons créer un sous-ensemble de données que nous allons appeler dataset_shs_alzheimer.

Notre filtrage des lignes est basé sur des conditions spécifiques : la fonction str_detect nous permettra de rechercher le motif "shs" ou "ssh" dans la colonne domain_s ou la colonne primaryDomain_s, avec la conversion en minuscules pour rendre la recherche insensible à la casse.

```{r, include=FALSE}

dataset_shs_alzheimer <- dataset_alzheimer %>%
  
  # Filtrage des lignes basé sur des conditions spécifiques
  filter(
    # Utilisation de str_detect pour rechercher le motif "shs" ou "ssh" dans la colonne domain_s
    # ou la colonne primaryDomain_s, avec la conversion en minuscules pour rendre la recherche insensible à la casse
    str_detect(tolower(domain_s), "shs|ssh") |
      str_detect(tolower(primaryDomain_s), "shs|ssh")
  )

```

Toujours dans l'optique de nettoyer nos données, vu que nous avons plusieurs types de publications, nous allons rassembler certaines avec d'autres.\

Nous allons donc agréger nos données liées aux types de publications.

Les principales modifications incluent :

-   Regrouper "ISSUE" avec "ART" dans la catégorie "Article dans une revue".

-   Regrouper "PROCEEDINGS" avec "COMM" dans la catégorie "Communication dans un congrès".

-   Regrouper "HDR" avec "THESE".

-   Regrouper "UNDEFINED" avec d'autres catégories d'"Autre publication scientifique".

-   Regrouper "COUV" avec "Ouvrages".

```{r, include=FALSE}

# Agréger les données dans la colonne docType_s
dataset_shs_alzheimer <- dataset_shs_alzheimer %>%
  mutate(docType_s = case_when(
    docType_s %in% c("ART", "ISSUE") ~ "Article dans une revue",
    docType_s %in% c("BLOG") ~ "Article de blog scientifique",
    docType_s %in% c("COMM", "PROCEEDINGS") ~ "Communication dans un congrès",
    docType_s %in% c("LECTURE") ~ "Cours",
    docType_s %in% c("OTHER", "VIDEO", "TRAD", "UNDEFINED") ~ "Autre publication scientifique",
    docType_s %in% c("OUV", "COUV") ~ "Ouvrages",
    docType_s %in% c("PATENT") ~ "Brevet",
    docType_s %in% c("POSTER") ~ "Poster de conférence",
    docType_s %in% c("REPORT") ~ "Rapport",
    docType_s %in% c("THESE", "HDR") ~ "Thèse",
    TRUE ~ as.character(docType_s)  
  ))


```

### Étape 2

Création d'un dataset pour analyser les données liées aux revues

Affichage des données liées aux types de documents

```{r, include=FALSE}

unique_doctype <- unique(dataset_alzheimer$docType_s) 
print(unique_doctype)
```

Vu que nous souhaitons nous concentrer sur les revues SHS, nous allons donc créer un nouveau dataset qui prend seulement les données liées aux revues.

Nous allons tout d'abord filtrer le jeu de données shs pour inclure uniquement les lignes où docType_s est "Article dans une revue" et où la colonne journalTitle_s contient les mots "Revue", "revue", "review" ou "Review" car il se peut que quelques revues ne soient pas indiquées comme étant des revues dans le type du document (undefined)

Filtrer le jeu de données pour inclure uniquement les lignes où docType_s est "ISSUE" ou "ART" et où la colonne journalTitle_s contient les mots "Revue", "revue", "review" ou "Review"

```{r, include=FALSE}
revues_shs_alzheimer <- dataset_shs_alzheimer %>%
  filter(
    docType_s %in% c("Article dans une revue") |
      str_detect(tolower(journalTitle_s), "revue|review")
  )
```

Nous avons donc 394 publications de revues.

**Nettoyage des données liées à la langue :**

Pour nettoyer nos données de langue, nous allons tout d'abord les afficher :

```{r, include=FALSE}

# Créer une table des occurrences de chaque langue
language_counts <- table(revues_shs_alzheimer$language_s)

# Afficher la table
print(language_counts)


```

Pour nettoyer notre colonne de langue, nous allons utiliser la librarie textcat. Cette librairie basé sur des modèles NLP pré-entrainés permet la détection automatique de la langue d'un texte. Il s'agit plus précisemment d'un N_gramm de la base de donnés pour 26 langues basé sur le corpus miltilingue de l'initiative Corpus Européen (<https://cran.r-project.org/web/packages/textcat/textcat.pdf>)

Nous avons choisi de détecter la langue de la colonne title_s

```{r}

library(textcat)

revues_shs_alzheimer$language_verification <- sapply(revues_shs_alzheimer$title_s, textcat)

# Afficher le dataframe avec la colonne language_verification
print(revues_shs_alzheimer)

```

Une colonne language_verification a été donc créé. Sauf que la libraire affiche le résultat comme étant : soit : french pour français, soit english pour anglais. Vu que nous souhaitons comparer nos résultats à ceux déjà saisis sur HAL, nous devons modifier l'output :

```{r}

# Modifier les valeurs en "fr" ou "en" en fonction de la langue détectée
revues_shs_alzheimer$language_verification <- ifelse(revues_shs_alzheimer$language_verification == "french", "fr",
                                                     ifelse(revues_shs_alzheimer$language_verification == "english", "en", NA))

```

Nous allons comparer ces données à celles déjà saisies sur HAL (donc language_s)

Filtrer les lignes où language_verification n'est pas égal à language_s

```{r, include=FALSE}

lignes_langue_différente <- revues_shs_alzheimer %>%
  mutate(language_verification = as.character(language_verification),
         language_s = as.character(language_s)) %>%
  filter(language_verification != language_s)

```

Afficher les lignes

```{r, include=FALSE}
print(lignes_langue_différente)
```

Maintenant que nous avons les lignes qui ne correspondent pas, nous allons vérifier manuellement si c'est le cas ou non, puis nous allons corriger les incohérences.

Nettoyer les données liées à la langue à partir de l'identifiant docid

```{r, include=FALSE}

revues_shs_alzheimer <- revues_shs_alzheimer %>%
  mutate(language_s = case_when(
    docid %in% c(1806639, 1240621, 984498, 1240619, 4375787, 3355729, 4457542, 4380879, 3524754,
                 4047932, 4391680, 2440803, 4201490, 1584518, 3817981, 4330838, 3730267, 4331180,
                 4375866, 3730264, 3497539, 3730263, 4334832, 3726046, 3643277, 4226480, 4334932,
                 4375647) ~ "fr",
    TRUE ~ language_s
  ))

```

Il y a également une incohérence dans les lignes concernant les éditeurs, nous allons mettre à jour la colonne journalPublisher_s :

```{r, include=FALSE}
revues_shs_alzheimer <- revues_shs_alzheimer %>%   
  mutate(     journalPublisher_s = if_else(journalPublisher_s == "Elsevier", "Elsevier Masson", journalPublisher_s)   )
```

Nous allons remplir les lignes vides dans journalPublisher_s par des NA pour pouvoir retirer les NA lors de nos analyses :

```{r}
revues_shs_alzheimer$journalPublisher_s <- replace(revues_shs_alzheimer$journalPublisher_s, revues_shs_alzheimer$journalPublisher_s == "", NA)

# Créer et afficher la table des occurrences
table_journal_publisher <- table(revues_shs_alzheimer$journalPublisher_s)
print(table_journal_publisher)
```

# Analyse pour répondre à nos questions

### Analyse 1 - Auteurs actifs

1.  Analyse des auteurs les plus actifs dans les revues SHS : Identification des auteurs avec le plus grand nombre de publications sur Alzheimer.

```{r, include=FALSE}
library(tidyverse) 
library(questionr) 
library(skimr) 
library(igraph)
```

```{r, include=FALSE}
view(revues_shs_alzheimer)

revues_shs_auteur <- revues_shs_alzheimer %>% select(1:14,26) 

skim(revues_shs_auteur) 

view(revues_shs_auteur)
```

distinguer les auteurs de chaque publication

```{r, include=FALSE}
revues_shs_auteur$AutList <- strsplit(revues_shs_auteur$authFullName_s, ",")
```

index : combien d auteurs par publications?

```{r, include=FALSE}
revues_shs_auteur$nbAut <- NA

for(i in 1:length(revues_shs_auteur$AutList)){
  revues_shs_auteur$nbAut[[i]] <- length(revues_shs_auteur$AutList[[i]])}
```

format long : une ligne par collection

```{r, include=FALSE}
revues_shs_auteur <- revues_shs_auteur[rep(1:nrow(revues_shs_auteur), 
                                           revues_shs_auteur$nbAut),]
```

une collection par ligne par ordre de citation, si l'id HAL est identique à la ligne précédente, ajouter 1

```{r, include=FALSE}
revues_shs_auteur$ordre <- NA

revues_shs_auteur$ordre[1] <- 1

for(i in 2:length(revues_shs_auteur$ordre)){
  {if(revues_shs_auteur$docid[i]==revues_shs_auteur$docid[i-1]){ revues_shs_auteur$ordre[i] <- revues_shs_auteur$ordre[i-1]+1 } else (revues_shs_auteur$ordre[i] <- 1)}

}
```

auteurs

```{r, include=FALSE}
revues_shs_auteur$Auteur <- NA

for(i in 1:length(revues_shs_auteur$ordre)){
  revues_shs_auteur$Auteur[i] <- revues_shs_auteur$AutList[[i]][revues_shs_auteur$ordre[i]]}

view(revues_shs_auteur)
```

Créer un nouveau jeu de données pour faire visible la collaboration des auteurs

```{r, include=FALSE}
install.packages("data.table")
library(data.table)

fwrite(revues_shs_auteur, file ="aut_collab.csv",row.names = TRUE)
```

auteurs actifs

```{r, include=FALSE}
aut_actif <- table(revues_shs_auteur$Auteur)
aut_actif_df <- data.frame(aut = names(aut_actif), frequentation = as.numeric(aut_actif)) 
top_aut <- aut_actif_df[order(aut_actif_df$frequentation, decreasing = TRUE), ]

top_10 <- head(top_aut, 10)
view(top_10)

ggplot(top_10, aes(x = reorder(aut, -frequentation), y = frequentation)) + 
  geom_bar(stat = "identity", fill = "skyblue") + 
  labs(title = "Top 15 Authors by Frequency", x = "Author", y = "Frequency") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Analyse 2 - Réseau de collaboration

2.  Analyse du réseau de collaborations des auteurs des revues SHS: Construction d'un réseau de collaborations entre auteurs, identification des groupes fréquemment actifs.

collaboration (igraph)

```{r, include=FALSE}
aut_collab <- revues_shs_auteur %>% 
  select(docid,Auteur) %>% 
  filter(Auteur %in% c("Mohamad El Haj","Philippe Allain","Cédric Annweiler","Jean-Pierre Jacus","Karim Gallouj","Olivier Beauchet","Pascal Antoine","Fabrice Gzil","Ahmed Moustafa","Marie-Christine Gély-Nargeot"))

aut_collab_graph <- graph_from_data_frame(aut_collab, directed = FALSE)
```

Plot 1

```{r, include=FALSE}
plot(aut_collab_graph, main = "Collab d'auteurs",vertex.label.cex=0.7, vertex.label.color="black")

bipartite.mapping(aut_collab_graph)$res
V(aut_collab_graph)$type <- bipartite_mapping(aut_collab_graph)$type
```

Plot 2

```{r, include=FALSE}
gg <- graph.data.frame(aut_collab,directed=FALSE) 

plot(gg, vertex.color = "orange", edge.label=aut_collab$value, vertex.size=2, edge.color="orange", vertex.label.font=1, edge.label.font =1, edge.label.cex = 1, vertex.label.cex = 0.68,vertex.label.color="black")
```

### Analyse 3 - Nuage de mots (titres)

3\. Nuage de mots des titres des revues SHS : Création d'un nuage de mots basé sur les titres des publications pour visualiser les termes les plus fréquents.

il y a quelques groupes plus actifs, mais le nombre de fois qu'ils ont travaillé ensemble est petit (2 fois)

```{r, include=FALSE}
library(wordcloud) 
library(tm) 
library(SnowballC) 
library(RColorBrewer)
```

```{r, include=FALSE}
nuage <- data.frame(revues_shs_alzheimer) 
nuage_corpus <- Corpus(VectorSource(revues_shs_alzheimer$title_s))

nuage_corpus_clean<-tm_map(nuage_corpus,tolower)
nuage_corpus_clean<-tm_map(nuage_corpus_clean,removeNumbers)
nuage_corpus_clean<-tm_map(nuage_corpus_clean,removeWords,stopwords("english"))
nuage_corpus_clean<-tm_map(nuage_corpus_clean,removeWords,stopwords("fr"))
nuage_corpus_clean<-tm_map(nuage_corpus_clean,removeWords, c("alzheimer", "maladie", "disease"))
nuage_corpus_clean <- tm_map(nuage_corpus_clean, content_transformer(function(x) gsub("[[:punct:]]", "", x)))
nuage_corpus_clean<-tm_map(nuage_corpus_clean,removePunctuation)
nuage_corpus_clean<-tm_map(nuage_corpus_clean,stripWhitespace)

wordcloud(nuage_corpus_clean,max.words = 100, min.freq =1, colors = viridis_pal()(6), rot.per=0.35)

```

### Analyse 4 - Tendances de publications

Visualisations :

1\. Analyse des tendances de publication au fil des années : Identification des tendances globales et par type de publication

Chargement des bibliothèques nécessaires :

```{r, include=FALSE}
library(ggplot2) 
library(dplyr) 
library(viridis)
```

Analyse des données :

Nous allons calculer le nombre de publications pour chaque année et type de document en créant un data frame de résumé

```{r, include=FALSE}
tendances_publication <- dataset_shs_alzheimer %>%
  group_by(publicationDateY_i, docType_s) %>%
  summarise(count = n()) %>%
  filter(!(docType_s %in% c("UNDEFINED")))

```

Visualisation des données avec la palette de couleurs viridis :

```{r, include=FALSE}
ggplot(tendances_publication, aes(x = publicationDateY_i, y = count, fill = docType_s)) +
  geom_bar(stat = "identity", position = "stack", width = 0.7, color = "black") +
  scale_fill_brewer(palette = "Dark2") +
  labs(
    title = "Tendances des publications SHS sur la maladie d'Alzheimer au fil des années",
    x = "Année de publication",
    y = "Nombre de publications",
    fill = "Type de document"
  ) +
  theme_minimal() +
  scale_x_continuous(breaks = unique(tendances_publication$publicationDateY_i), labels = unique(tendances_publication$publicationDateY_i))

```

Analyse :

-   En 1998, les publications exclusivement dédiées à la maladie d'Alzheimer dans le domaine des SHS étaient toutes des ouvrages.

-   À partir de 2001, chaque année (à l'exception de 2004), des articles portant sur la maladie d'Alzheimer dans le domaine des SHS ont été publiés dans des revues.

-   L'année 2017 a enregistré un pic dans le nombre de publications dédiées à la maladie d'Alzheimer dans le domaine des SHS.

-   En 2023, il y a eu une augmentation significative du nombre d'ouvrages publiés par rapport aux années précédentes dans le domaine des SHS traitant de la maladie d'Alzheimer.

### Analyse 5 - Analyse de la répartition des publications SHS

Tout d'abord, il faut installer et charger le package ggrepel s'il n'est pas déjà installé

```{r, include=FALSE}
library(ggrepel)
```

Nous allons créer un résumé des comptes et pourcentages pour chaque catégorie docType_s :

```{r, include=FALSE}
count_data <- dataset_shs_alzheimer %>%
  count(docType_s) %>%
  mutate(percentage = prop.table(n) * 100)

```

Nous allons créer un camembert avec des étiquettes de pourcentage à l'extérieur et des flèches :

```{r, include=FALSE}

ggplot(count_data, aes(x = "", y = n, fill = docType_s)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  
  geom_label_repel(aes(
    label = scales::percent(percentage / 100),
    fill = docType_s
  ),
  position = position_stack(vjust = 0.5),
  box.padding = 0.5,
  point.padding = 0.3,
  arrow = arrow(length = unit(0.02, 'npc')),
  show.legend = FALSE) +
  
  coord_polar("y", start = 0) +
  scale_fill_brewer(palette = "Dark2") +
  theme_void() +
  theme(axis.text = element_blank()) +
  labs(title = "Répartition des types de publications sur la maladie d'Alzheimer",
       fill = "Type de publication")

```

Analyse :

-   La catégorie la plus prédominante est "Article dans une revue", représentant environ 47.24% de l'ensemble des types de documents.

-   "Communication dans un congrès" représente une part significative, soit environ 19.78% de l'ensemble.

-   Les "Ouvrages" représentent environ 14.51% de l'ensemble, contribuant de manière notable.

-   Environ 10.19% des types de documents sont classés comme "Thèse", une part significative mais inférieure à d'autres catégories.

-   Les "Poster de conférence" constituent une part relativement faible, soit environ 2.99%.

-   La catégorie "Rapport" représente environ 2.28% de l'ensemble, une part modérée.

-   Environ 2.99% des types de documents sont classés comme "Autre publication scientifique".

### Analyse 6 - Les institutions les plus actives dans la publications des articles des revues SHS

Nous allons supprimer les NA dans journalPublisher_s. Il faut les supprimer dans cette étape et non pas lors du nettoyage pour garder les lignes qui servent pour d'autres analyses.

```{r, include=FALSE}
revues_shs_alzheimer <- revues_shs_alzheimer %>%
  filter(!is.na(journalPublisher_s))
```

-   Cette ligne de code utilise la fonction **`filter`** pour exclure les lignes où la colonne **`journalPublisher_s`** a des valeurs **`NA`**. Cela nettoie le dataframe en retirant les observations avec des valeurs manquantes dans la colonne spécifiée.

    Nous allons maintenant sélectionner le top 10 des éditeurs de revue les plus actifs:

```{r, include=FALSE}
top_institutions <- revues_shs_alzheimer %>%
  count(journalPublisher_s) %>%
  arrange(desc(n)) %>%
  head(10)
```

Cette séquence de commandes utilise **`count`** pour compter le nombre d'occurrences de chaque éditeur de revue, puis **`arrange`** pour les trier par ordre décroissant en fonction du nombre de publications (**`n`**). Enfin, **`head(10)`** est utilisé pour sélectionner les 10 éditeurs avec le nb le plus élevé.

Nous allons maintenant créer une visualisation :

```{r, include=FALSE}
ggplot(top_institutions, aes(x = n, y = fct_reorder(journalPublisher_s, n))) +
  geom_bar(stat = "identity", fill = "#E6AB02", color = "black") +
  labs(
    title = "Institutions les plus actives dans les revues SHS sur la maladie d'Alzheimer",
    x = "Nombre de publications",
    y = "Institution"
  ) +
  scale_x_continuous(breaks = seq(0, max(top_institutions$n), by = 7)) +
  theme_minimal()
```

Les barres sont remplies avec la couleur **`#E6AB02`** qui fait partie de la palette Dark2.

Le choix d'afficher le nombre de publications par 7 permet de bien visualiser l'axe X autant plus que les derniers éditeurs ont publié 7 publications.

### Analyse 9 - Répartition des langues des publications des revues

```{r, include=FALSE}
# Créer une table des langues
langue_pays_freq <- revues_shs_alzheimer %>%
  count(language_s) %>%
  arrange(desc(n))

# Créer la visualisation avec un graphique à barres empilées
ggplot(langue_pays_freq, aes(x = fct_reorder(language_s, n), y = n)) +
  geom_bar(stat = "identity", fill = "#E6AB02", color = "black") +  # Modifier les couleurs
  labs(
    title = "Répartition des langues des publications SHS sur la maladie d'Alzheimer",
    x = "Langue",
    y = "Nombre de publications",
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### Analyse n - Top des revues les plus actives

Nous allons tout d'abord ressortir le top 20 des revues ayant le nb le plus élevé des publications

```{r}
# Analyse des revues les plus actives
top_revues <- revues_shs_alzheimer %>%
  count(journalTitle_s) %>%  # Compter le nombre de publications par revue
  arrange(desc(n)) %>%  # Trier par ordre décroissant du nombre de publications
  head(20)  # Sélectionner les 20 revues les plus actives
```

Nous allons attribuer une discipline à chacune de ces revues. Pour ce faire, nous avons chercher sur le moteur de recherche HAL pour identifier le domaine dans lequel chaque revue publie le plus.

```{r}
top_revues <- top_revues %>%
  mutate(domaine_revue = case_when(
    journalTitle_s == "Journal of Alzheimer's Disease" ~ "Life Sciences",
    journalTitle_s == "NPG: Neurologie - Psychiatrie - Gériatrie" ~ "Humanities and Social Sciences",
    journalTitle_s == "Gériatrie et psychologie & neuropsychiatrie du vieillissement" ~ "Life Sciences",
    journalTitle_s == "Psychologie & NeuroPsychiatrie du vieillissement" ~ "Life Sciences",
    journalTitle_s == "Retraite et société" ~ "Humanities and Social Sciences",
    journalTitle_s == "Current Alzheimer Research" ~ "Life Sciences",
    journalTitle_s == "Revue Neurologique" ~ "Life Sciences",
    journalTitle_s == "Gérontologie et Société" ~ "Humanities and Social Sciences",
    journalTitle_s == "L'Encéphale" ~ "Life Sciences",
    journalTitle_s == "Cortex" ~ "Life Sciences",
    journalTitle_s == "Neuropsychology" ~ "Cognitive science",
    journalTitle_s == "Soins Gérontologie" ~ "Life Sciences",
    journalTitle_s == "Annales Médico-Psychologiques, Revue Psychiatrique" ~ "Humanities and Social Sciences",
    journalTitle_s == "Archives of Clinical Neuropsychology" ~ "Cognitive science",
    journalTitle_s == "Brain and Cognition" ~ "Life Sciences",
    journalTitle_s == "Journal de droit de la santé et de l'assurance maladie" ~ "Humanities and Social Sciences",
    journalTitle_s == "Journal of Clinical and Experimental Neuropsychology" ~ "Cognitive science",
    journalTitle_s == "L'Évolution Psychiatrique" ~ "Humanities and Social Sciences",
    journalTitle_s == "RDSS. Revue de droit sanitaire et social" ~ "Humanities and Social Sciences",
    journalTitle_s == "Sciences Sociales et Santé" ~ "Humanities and Social Sciences",
    TRUE ~ "Autre"
  ))
```

Maintenant nous allons créer notre graphique des revues les plus actives qui mentionne également le domaine des revues

```{r}

# Créer un graphique à barres des revues les plus actives avec domaine_revue
ggplot(top_revues, aes(x = n, y = fct_reorder(journalTitle_s, n), fill = domaine_revue)) +
  geom_bar(stat = "identity", color = "black") +
  labs(
    title = "Revues les plus actives dans les publications SHS sur la maladie d'Alzheimer",
    x = "Nombre de publications",
    y = "Revue",
    fill = "Domaine de revue"
  ) +
  scale_fill_brewer(palette = "Dark2") +  
  theme_minimal()

```

# Interprétations des résultats

# Création d'un taggage via Zotero

# Création d'une bibliographie sur Zotero

# Conclusion
